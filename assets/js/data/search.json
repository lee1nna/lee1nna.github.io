[ { "title": "[Typescript] 타입 별칭(Alias)과 인터페이스(Interface)", "url": "/posts/TS-Type-Alias-Interface/", "categories": "Typescript", "tags": "Front-End, Typescript, alias, interface", "date": "2023-02-21 00:00:00 +0900", "snippet": "이번 글에서는 타입스크립트에 유사한 타입 별칭과 인터페이스에 대해 알아보고 그 둘의 차이점에 대해 알아보자.타입 별칭 (Type Alias)타입 별칭은 새로운 타입을 생성한다는 개념이라기 보다는 정의한 타입에 대해 쉽게 참고할 수 있도록 이름을 부여한 것이다. 타입 별칭은 type 키워드를 사용하여 선언할 수 있다.type Person = { name: string, age: number}타입 별칭을 타입으로 지정해둔 변수의 타입에 마우스를 올리면 Vscode 개발툴에서는 다음과 같이 보여준다.인터페이스 (Interface)타입 인터페이스는 여러가지 타입을 갖는 프로퍼티로 이루어진 새로운 타입을 정의하는 것과 유사하다인터페이스는 interface 키워드를 사용하여 선언할 수 있다.interface Person { name: string, age: number}인터페이스 타입으로 지정해둔 변수의 타입에 마우스를 올리면 Vscode 개발툴에서는 다음과 같이 보여준다.보통 별도의 파일에 필요한 인터페이스를 선언한 후 해당 인터페이스가 필요한 파일에서 인터페이스를 import해와서 사용한다.타입 별칭과 인터페이스의 차이점타입 별칭과 인터페이스의 가장 큰 차이점은 확장성의 유무이다.타입 별칭은 확장이 불가능하고, 인터페이스는 extends 키워드를 통해 확장이 가능하다.좋은 소프트웨어는 확장이 용이해야하기 때문에 가급적이면 확장이 가능한 인터페이스를 사용하는 것이 더 좋다 !!" }, { "title": "[Vue] store와 vuex는 무엇인가?", "url": "/posts/Vue-store-basic/", "categories": "FE 지식", "tags": "Front-End, Vue, Store, Vuex", "date": "2022-12-22 00:00:00 +0900", "snippet": "Vue에서 상태관리에 필수적인 store에 대해 알아보자.store와 vuexstore는 애플리케이션 전역에서 접근 가능한 중앙 집중식 데이터 저장소이다.한마디로 API를 통해 받은 데이터와 컴포넌트를 제어하는 값들을 한 곳에서 관리하려고 만든 구조이다.store는 데이터의 흐름을 단방향으로 제어한다.vuex는 vue의 상태관리 라이브러리이다.vuex가 각각의 컴포넌트에 사용되어야 할 상태를 관리하고 이 상태는 트리 구조의 root처럼 모든 상태의 값을 관리한다.store의 기본 구조store는 다음과 같이 4가지의 구조를 가진다. state : 변수들의 집합, 변수 정의부 mutations : 동기적으로 변수 재정의, 조작, 값 대입 등 변화를 주는 조작부 actions : 비동기적으로 동작을 처리하는 통신부, 비동기 함수들의 집합 getters : state 상태 값을 원하는 포맷이나 타입으로 가공해 반환store - statestate는 공통으로 참조하기 위한 변수를 정의하는 공간이다.프로젝트의 모든 곳에서 이곳에 정의된 변수를 참조하고 사용할 수 있다.state = () =&amp;gt; ({ stateA: [], stateB: [],})store - mutaionsmutations은 state 값의 변경을 담당하는 공간이다.mutations을 통해서만 state의 값을 변경할 수 있으며 동기 처리 기준이다.비즈니스로직을 담고 있으면 안되며, 가능한한 외부에서는 부르지 않고 actions에서만 불리는 것이 좋다.commit(’mutations 함수명’, ‘전달인자’) 방식으로 호출하여 사용한다.mutations = { changeStateA(state, newStateA) { state.stateA = newStateA }, changeStateB(state, newStateB) { state.stateB = newStateB }store - actionsactions는 주로 mutations를 실행시키는 트리거 역할을 한다.보통 API 호출이나 그 결과에 대해 반환하거나 결과를 mutation으로 commit하여 상태를 변경하는 용도로 사용된다. 대다수의 경우 Promise를 리턴하게 된다.dispatch(’actions 함수명&#39;, ‘전달인자’) 방식으로 호출하여 사용한다.actions = { setStateA({commit}, payloadA) { commit(&#39;changeA&#39;, payloadA) } setStateB({commit}, payloadB) { commit(&#39;changeB&#39;, palyoadB) }}store - gettersgetters는 computed와 비슷한 역할로 상태 값 state를 반환한다.getters = { getStateA(state) { return state.stateA } getStateB(state) { return state.stateB }}store는 store &amp;gt; index.js에서 모든 구조를 정의하는 단일 스토어 방식과, 역할별로 파일을 나누어 구조를 정의하는 모듈화 방식이 있는데 주로 규모가 어느정도 있는 프로젝트에서는 모듈화 방식을 사용한다.실무에서 vuex를 사용하는 방식은 각자의 코딩스타일에 따라 조금씩 변경되는 듯하다.이 포스팅을 작성하다가 vuex 컨벤션이 있나싶어 알아보았는데, 여태 잘못된 방식으로 vuex를 사용하고 있다는 것을 깨달았다. 알맞는 컨벤션을 사용해 위에 정의했던 변수명과 함수명을 수정해보자.// State -&amp;gt; 중첩금지, 단어 구분은 언더바 사용 (ex. category-id)state = () =&amp;gt; ({ state_a: [], state_b: [],})// Getters -&amp;gt; is로 시작하거나 get으로 시작, 단어 구분은 camelCase 사용 (ex.getUserId)getters = { getStateA(state) { return state.stateA } getStateB(state) { return state.stateB }}// Actions -&amp;gt; 역할에 맞게 fetch, set으로 시작, 단어 구분은 camelCase 사용 (ex. fetchProduct)actions = { fetchStateA({commit}, payloadA) { commit(&#39;changeA&#39;, payloadA) } fetchStateB({commit}, payloadB) { commit(&#39;changeB&#39;, palyoadB) }}// Mutations -&amp;gt; 모두 대문자 사용, 단어 구분은 언더바 사용 (ex. SET_XXX, ADD_XXX, REMOVE_XXX)mutations = { SET_STATE_A(state, newStateA) { state.stateA = newStateA }, SET_STATE_B(state, newStateB) { state.stateB = newStateB }각각 컨벤션 규칙이 달라서 작성할때 번거로울 수는 있겠지만 유지보수의 용이성을 위해서 앞으로는 컨벤션 규칙을 지켜서 vuex를 사용하자 !! 참고자료 https://fe-churi.tistory.com/24 https://kdydesign.github.io/2019/05/09/vuex-tutorial/ https://velog.io/@nuxt/Vuex-명명-규칙 " }, { "title": "[React + Webpack] 웹팩 세팅 + 빌드하기", "url": "/posts/React-Webpack-Setting/", "categories": "React", "tags": "React, Webpack", "date": "2022-11-09 00:00:00 +0900", "snippet": " 프로젝트 파일 들어가서 npm init 실행하면 package.json 파일 생성 npm react react-dom npm i -D webpack webpack-cli npm i -D babel-loader @babel/core npm i -D @babel/preset-env npm i -D @babel/preset-react 프로젝트 폴더에 webpack.config.js 파일 추가// webpack.config.jsconst path = require(&#39;path&#39;);module.exports = { mode:&#39;development&#39;, devtool: &#39;eval&#39;, // 개발일 땐 eval, 프로덕션일 땐 hidden-source-map resolve: { extensions: [&#39;.jsx&#39;, &#39;js&#39;] }, entry: { app: &#39;./client.jsx&#39; }, module: { rules: [{ test: /\\.jsx?$/, loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;], } }], }, output: { filename: &#39;app.js&#39;, path: path.join(__dirname, &#39;dist&#39;) }}// package.json{ &quot;name&quot;: &quot;gugudan&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack&quot; // 해당 스크립트 추가 }, &quot;author&quot;: &quot;leehanna&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: { &quot;react&quot;: &quot;^18.2.0&quot;, &quot;react-dom&quot;: &quot;^18.2.0&quot; }, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.20.2&quot;, &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;, &quot;@babel/preset-react&quot;: &quot;^7.18.6&quot;, &quot;babel-loader&quot;: &quot;^9.1.0&quot;, &quot;webpack&quot;: &quot;^5.74.0&quot;, &quot;webpack-cli&quot;: &quot;^4.10.0&quot; }}웹팩 세팅과 스크립트 설정이 끝나면 npm run dev 를 실행한다.프로젝트 폴더에 dist파일이 생성되면 웹팩 빌드가 성공한 것이다 !!" }, { "title": "[Javascript] HashMap - Map 객체", "url": "/posts/Hash-Map/", "categories": "Javascript", "tags": "Javascript, Hash-map, Map", "date": "2022-10-12 00:00:00 +0900", "snippet": "해시테이블 (Hash Table)자료 구조의 종류 중 하나로 key와 value를 가지는 자료구조 형태이다.배열은 key값에 숫자만 가능하지만, hash table에서는 문자열 또한 key값이 가능하다.hash function을 통해 빠른 탐색O(1)이 가능하다.해시 함수 (Hash function)key와 연결되어 있는 value를 삽입, 삭제, 탐색하는 알고리즘 함수이다.key가 들어오면 random하게 주소값을 생성한 후, 해당 주소값에 key와 value를 저장한다.javascript에서 해시테이블은 대표적으로 Object, Map, Set이 있다. JS에서 key-value로 이루어진 자료구조는 Object가 대표적이었지만, ES6에서 Map과 Set이 추가되었다.해시테이블 MapMap 객체 key-value로 이루어진 해시 테이블 탐색은 get(key), 삽입은 set(key, value) key는 고유값으로 단 한개만 존재 key가능한 자료형: number, string, function, object, NaN1. Map 객체 생성let map = new Map()2. Map.set() | 데이터 삽입map.set(0, 1) // key: 0map.set(&#39;isKey&#39;, 2) // key: &#39;isKey&#39;map.set({a:1}, 3) // key : {a:1}map.set(() =&amp;gt; {console.log(&#39;function&#39;)}, 4) // key: () =&amp;gt; {console.log(&#39;function&#39;)}map.set(0, 3) // 덮어쓰기 가능3. Map.get() | key값으로 value찾기// key값으로 value 찾기map.get(0) // 1map.get(&#39;isKey&#39;) // 2map.get({a:1}) // 3map.get(() =&amp;gt; {console.log(&#39;function&#39;)}) // 44. Map.has() | key값으로 value유무 확인하기map.has(0) // truemap.has(&#39;isKey&#39;) // truemap.has({a:1}) // truemap.has(() =&amp;gt; {console.log(&#39;function&#39;)}) // truemap.has(&#39;abc&#39;) // false5. Map.size | Map 크기 확인하기map.size // 46. Map.delete() | key값으로 value 삭제하기map.delete(0)map.delete(&#39;isKey&#39;)map.delete({a:1})map.delete(() =&amp;gt; {console.log(&#39;function&#39;)})그렇다면 object와 비교했을때 map을 사용하면 좋은 점은 무엇일까?object보다 map을 사용하면 좋은 이유 더 많은 key의 유형 size 사용 가능 더 나은 성능 반복문 사용 가능위 내용만 보았을 경우에는 object보다 map이 더 많은 장점을 가지고 있는 듯 하지만, 어떤 경우에서는 object가 더 나은 성능을 보일 때도 있다. 따라서 상황에 맞게 적절하게 사용해주는 것이 좋다. 참고자료 Javascript에서 Object를 해시맵처럼 사용하지 마세요 JS Map과 해시맵 " }, { "title": "[Nuxt + Typescript] 카카오톡 공유하기 sdk 사용하기", "url": "/posts/Nuxt-Kakao-Share/", "categories": "Typescript", "tags": "Nuxt, Typescript, Kakao, Share", "date": "2022-09-28 00:00:00 +0900", "snippet": "카카오톡에서는 다양한 기능의 sdk를 제공한다.이번 포스팅에서는 그 중에서 카카오톡 공유하기 sdk를 nuxt 환경에서 어떻게 사용할 수 있는 지 순서대로 알아보자!참고로 나는 nuxt2 + composition API + typescript 환경에서 진행했다.1. 애플리케이션 등록먼저 카카오톡 sdk 를 사용하기 위해서는 카카오톡 개발자 홈페이지에서 애플리케이션을 등록해야 한다.로그인 후 애플리케이션 추가하기를 통해 애플리케이션 등록을 할 수 있다.애플리케이션 등록 후에는 위와 같이 앱 정보를 확인할 수 있다.나는 웹 플랫폼에서 sdk를 사용할거기 때문에 Javascript 키가 꼭 필요하다!2. 웹 플랫폼 등록이제 웹 플랫폼을 등록해보자.웹 플랫폼은 아래 사진에서 보이는 경로로 등록이 가능하다.웹 등록을 할때 사이트 url을 적게 되는데 보통 카카오톡 공유하기 기능을 사용할 서비스 url을 적는다.하지만 나는 테스트가 목적이기 때문에 http://localhost:3000로 등록을 진행했다.3. Nuxt에서 카카오톡 sdk 사용하기nuxt에서 쉽게 카카오톡 sdk를 사용하기 위해서 vue-kakao-sdk 설치한다.npm install vue-kakao-sdk4. 플러그인 설정설치한 vue-kakao-sdk를 사용하기 위해서 플러그인을 추가해준다. 📂 /plugins/kakao.jsimport Vue from &#39;vue&#39;import VueKakaoSdk from &#39;vue-kakao-sdk&#39;const apiKey = &#39;Your Kakao API Javascript Key&#39;// You have to pass your &quot;Kakao SDK Javascript apiKey&quot;Vue.use(VueKakaoSdk, { apiKey })apiKey 변수에 이전에 애플리케이션 등록 후 받은 Javascript키를 넣어준다.플러그인 생성 후 nuxt.config.ts파일에서 plugins 경로를 연결해준다.📂 /nuxt.config.tsplugins: [ {src: &#39;~plugins/kakao.js&#39;} ],플러그인 경로 연결 후 만약 window is not defined 에러가 발생했다면, 아래 ssr 속성을 추가해준다.📂 /nuxt.config.tsplugins: [ {src: &#39;~plugins/kakao.js&#39;, ssr:false} ],5. 카카오톡 공유하기 기능 사용하기자 이제 모든 세팅을 마쳤으니 공유하기 기능을 사용해보자.카카오톡 공유하기는 템플릿이 있는데 이 템플릿을 지정하는 방식은 두가지가 있다. 카카오에서 제공하는 템플릿 빌더 사용 내가 직접 코드로 템플릿 제작두가지 방법중 어느 방법을 사용해도 무관하다. 먼저 1번 방법에 대해 알아보자.5-1. 카카오에서 제공하는 템플릿 빌더 사용메시지 템플릿 빌더 바로가기 링크로 이동하면 템플릿을 만들 수 있다.어느 영역에 어떤 정보가 들어가는지 엄청 직관적으로 잘나와 있어서 문제 없이 템플릿을 제작할 수 있다.${argument} 을 통해 동적으로 변수값을 받아서 처리해 줄 수도 있다.템플릿 빌더를 만들었으면 이제 카카오 공유하기 기능을 구현해보자.&amp;lt;template&amp;gt; &amp;lt;button @click=&quot;shareKakao&quot;&amp;gt; 카카오톡 공유하기 &amp;lt;/button&amp;gt;&amp;lt;/template&amp;gt;setup(){ const shareKakao = () =&amp;gt; { window.Kakao.Share.sendScrap({ requestUrl: &#39;http://localhost:3000/&#39;, templateId: 83474 //template ID }); } return { shareKakao } }위 코드로 간단하게 카카오톡 공유하기 기능을 구현할 수 있다.sendScrap에 들어가는 속성들은 카카오톡 공유하기에서 모두 확인할 수 있다.typescript를 사용할 경우에는 window.kakao에 아래와 같은 에러가 날 수 있다.window객체에 kakao프로퍼티가 추가가 되어있지 않아서 나는 에러로 index.d.ts 파일을 생성해 다음과 같이 프로퍼티를 추가해준다.export {};declare global { interface Window { Kakao: any; }}카카오톡 템플릿 빌더를 사용해 공유하기 기능을 구현한 결과이다 !!!5-2. 내가 직접 코드로 템플릿 제작내가 직접 코드로 템플릿을 제작하는 방법도 어렵지 않다.sendScrap을 sendDefault로 변경하고 템플릿에 추가하고 싶은 속성들을 추가해주면 된다.const shareKakao = () =&amp;gt; { window.Kakao.Share.sendDefault({ objectType: &#39;feed&#39;, content: { title: &#39;직접 만든 템플릿&#39;, description: &#39;설명부분 입니다&#39;, imageUrl: &#39;https://mblogthumb-phinf.pstatic.net/MjAxOTA4MjVfMjgg/MDAxNTY2NjYzNTA3MjEy.vWFFLv1u7SzDBes1sRdbFhn5uB8WnnbG95hAiWHkzV0g.r9fWqRf8vSfbDP_NlOGE_YA38GAcT50ZJLkTymx3a7Ag.JPEG.cdhh108/889F9465-4BD3-4523-8D8B-409CD0D70453.jpg?type=w800&#39;, imageWidth: 340, imageHeight: 600, link: { mobileWebUrl: &#39;http://localhost:3000/&#39;, androidExecutionParams: &#39;test&#39;, }, }, buttons: [ { title: &#39;카카오톡 공유하기 기능 만들러가기&#39;, link: { mobileWebUrl: &#39;http://localhost:3000/&#39;, webUrl: &#39;http://localhost:3000/&#39;, }, }, ], })}직접 템플릿을 사용해 구현한 결과이다." }, { "title": "[React + Typescript] interface를 사용한 props 전달하기", "url": "/posts/React-TS-props/", "categories": "Typescript", "tags": "React, Typescript, props", "date": "2022-09-12 00:00:00 +0900", "snippet": "react + typescript를 사용해서 props를 전달하면 다음과 같은 에러메시지가 뜬다.아래에 나와있듯이 props: any 를 사용하면 문제가 해결된다.그치만 타입스크립트에서 any는 가급적 안쓰는 것이 좋기 때문에 interface를 사용해 props의 타입을 지정해주어 해당 타입 에러를 없애보자!props를 전달 받을 자식 컴포넌트에 최상단에 interface를 사용해서 타입을 선언해준다.interface tooltipProps { tooltipBgColor: string}이전에 에러가 발생했던 props 파라미터 부분에 타입을 정의해준다.function Tooltip(props: tooltipProps)props를 사용할 때에는 다음과 같이 사용한다.&amp;lt;div className=&#39;tooltip_wrap&#39; style=&amp;gt;props를 생략하기 위해 구조분해할당을 사용할 경우에는 다음과 같이 타입을 정의해준다.function Tooltip({tooltipBgColor}:tooltipProps)그럼 다음과 같이 props를 생략하여 사용이 가능하다.&amp;lt;div className=&#39;tooltip_wrap&#39; style=&amp;gt;" }, { "title": "[Error Report] react-scripts: command not found 에러 해결 방법", "url": "/posts/ER-react-1/", "categories": "FE 지식", "tags": "React, Error", "date": "2022-08-24 00:00:00 +0900", "snippet": "리액트 프로젝트를 시작하기위해 git repository를 clone하고 npm run start 명령어를 입력했더니다음과 같은 에러가 발생했다.별다른 에러에 대한 설명이 없어서 잠시 당황했지만 npm install을 하지 않앗다는 걸 깨달았다.프로젝트 시작 전에 매번 하는 일인데도 가끔 까먹는다 🥲" }, { "title": "[FE 지식] Semantic Tag와 Semantic Web", "url": "/posts/Semantic-web/", "categories": "FE 지식", "tags": "Front-End, Semantic-tag, Semantic-web, SEO", "date": "2022-08-21 00:00:00 +0900", "snippet": "Semantic Tag?html에는 Semantic Tag라는 것이 존재한다.w3schools.com에서Semantic Tag 는 다음과 같이 정의한다.💡 What are Semantic Elements?시멘틱 요소는 자신의 의미를 브라우저와 개발자 모두에게 명확하게 설명한다.non-semantic 요소들의 예: &amp;lt;div&amp;gt; 와 &amp;lt;span&amp;gt; : 자신의 컨텐츠에 대해 아무것도 설명해주지 않는다.semantic 요소들의 예: &amp;lt;form&amp;gt;, &amp;lt;table&amp;gt;, &amp;lt;article&amp;gt; : 자신의 컨텐츠를 명확하게 정의한다.Semantic Web?그렇다면 Semantic Web 은 무엇일까?Semantic Web 이란 컨텐츠의 의미를 부여한 요소인 Semantic Tag 를 사용해서 구축한 웹 사이트를 말한다. 웹 크롤러가 웹 사이트의 의미와 컨텐츠의 내용을 이해하도록 하여 더 고품질의 정보를 수집하고 처리할 수 있도록 하는 것에 도움을 준다.또한, 시멘틱 웹은 시각 장애가 있는 유저가 사용하는 Screen reader에게 정보를 제공하는 것에도 사용될 수 있다. 📍 Screen reader란?컴퓨터 화면 내 문자를 음성으로 읽어주는 SW왜 Semantic Web을 사용해야 할까?시멘틱 웹은 SEO에 유리하다. 📍 SEO란?Search Engine Optimization검색 유저에게 양질의 컨텐츠와 경험을 제공하는 것으로 포털 사이트 검색 엔진에 웹사이트를 상위에 노출시키기 위해 기술적으로 웹 사이트를 최적화하는 대책을 말한다.유저가 검색한 키워드와 웹 사이트의 컨텐츠가 연관성이 있다는 것을 웹 크롤러에게 인지 시켜주어야 웹 사이트가 상위에 노출될 수 있고 웹 크롤러로부터 높은 평가를 받은 웹사이트는 검색 순위의 상위권에 노출될 확률이 높아지게 된다.이 때 **Semantic Tag 를 사용해 구축한 사이트는 컨텐츠를 인식할 수 있기 때문에 검색 키워드와 Semantic Web의 컨텐츠가 서로 부합하는지 검토할 수 있다.**Semantic Tag는 어떻게 사용하는 것이 좋을까?출처: https://velog.io/@gud_wns/Semantic-Web과-Semantic-Tagheader웹 페이지 도입부, 주로 페이지 상단 웹사이트 로고와 네비게이션 링크를 감싸는 것에 사용한다.일반적으로 &amp;lt;body&amp;gt; 상단에 표기되어 웹 사이트의 Title이나 네비게이션이 존재하는 영역에 사용된다. 하지만 &amp;lt;article&amp;gt;. &amp;lt;section&amp;gt; 내에서도 사용될 수 있다. &amp;lt;body&amp;gt; 내에서 사용될 경우 : 웹 페이지 전체 헤더를 정의한다. &amp;lt;article&amp;gt;, &amp;lt;section&amp;gt; 내에서 사용될 경우 : 해당 영역에 대한 특정 헤더를 정의하는 경우에 사용한다.&amp;lt;nav&amp;gt;홈페이지의 메인 영역으로 연결하는 태그다. 대부분의 메뉴 버튼이나 링크, 탭으로 표현될 수 있다.&amp;lt;body&amp;gt; 하위의 &amp;lt;header&amp;gt;에 위치하기도 하며 링크 그룹을 모아둔 곳이다. 하위에 말고 동등한 위치에 두는 것이 SEO 측면으로 더 좋다. 는 하나의 문서에서 여러 개의 를 가질 수 있다. 단, 모든 링크가 안에 있어야 하는 것은 아니다. 한 페이지 당 1개를 사용해 네비게이션 메뉴에만 제한해서 쓰기도 한다. 내용을 쉽게 이해할 수 있도록 nav 요소 내부에는 비순차 목록(&amp;lt;ul&amp;gt;)을 사용하는 것이 좋다. 사이트 하단에 위치한 링크는 &amp;lt;footer&amp;gt;로 충분하다.&amp;lt;main&amp;gt;메인 컨텐츠 내용이 들어갈 태그다. &amp;lt;body&amp;gt;에 포함되지만 섹션 요소가 아니며, 페이지 당 여러개가 존재할 수는 있지만 단 1개만 시각적으로 보여야 한다. (나머지 main은 hidden 속성 처리 해주어야 한다.) 섹션 요소인 section, article, aside, nav 요소는 main 요소를 자식으로 포함할 수 없다. 타이틀은 &amp;lt;header&amp;gt;안 &amp;lt;h1&amp;gt;~&amp;lt;h6&amp;gt;로 하며 본문 내용은 주로 &amp;lt;p&amp;gt;를 사용한다.&amp;lt;section&amp;gt; 과 &amp;lt;article&amp;gt; article 내부에 section 태그를 포함할 수 있고, section 내부에 article 을 포함할 수 있다. 콘텐츠가 사이트에 포함된 독립적인 섹션의 성향이 크다면 section 요소 대신 article 요소를 사용하는 것이 좋다. &amp;lt;article&amp;gt; 은 웹 접근성을 위해 &amp;lt;header&amp;gt;로 감싼, 제목(h1~h6 요소)을 포함시켜 요소를 식별하게 하자. 마찬가지로 본문 내용은 &amp;lt;p&amp;gt; 를 사용하자. 만약 섹션 제목을 감춰야 하는 상황이라면 hidden 속성을 사용하면 된다.&amp;lt;aside&amp;gt; 문서의 주요 내용과 간접적으로 연관된 부분을 나타낸다. 참고자료 시멘틱 태그 Semantic Tag Semantic Web에 대해 더 깊이 알아보기 " }, { "title": "[Typescript] 타입스크립트 필수 문법", "url": "/posts/typescript-basic/", "categories": "Typescript", "tags": "Typescript, narrowing, assertion, type alias", "date": "2022-08-03 00:00:00 +0900", "snippet": "타입스크립트 시작하기 - static 웹페이지프레임워크를 사용하지 않고 그냥 static 웹페이지 개발시에 타입스크립트 사용하는 방법에 대해 알아보자. node.js 설치 npm install -g typescript 로 타입스크립트 설치 프로젝트 생성 프로젝트에 tsconfig.json 파일 추가한 후 아래 내용 추가{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;ES5&quot;, // js ES5 문법으로 컴파일 &quot;module&quot;: &quot;commonjs&quot; // module은 commonjs 방식으로 컴파일 }}타입스크립트는 브라우저에서 읽을 수 없기때문에 자바스크립트로 컴파일해주는 과정이 필요하다.따라서 ts → js 컴파일 시 옵션을 tsconfig.json 파일에 넣어주면 된다.타입을 지정하는 다양한 방법타입스크립트는 변수를 만들 때 타입 지정이 가능하다.변수명 :타입명 과 같이 작성한다.타입으로 쓸 수 있는 것은 원시타입 (string, number, boolean, bigint, null, undefined)과 객체타입([], {})등이 있다.let name :string = &#39;홍시&#39;name = 123타입을 미리 지정해놓으면 타입이 의도치 않게 변경될 경우 에러메시지를 띄워주기 때문에 사전에 타입 관련 버그들을 없앨 수 있다.array나 object 자료 타입은 다음과 같이 지정이 가능하다.let name :string[] = [&#39;홍시&#39;,&#39;홍홍&#39;]let person :{name:string, sex:string} = {name:&#39;홍시&#39;, sex:&#39;여자&#39;}만약 변수에 여러가지 타입의 데이터가 들어올 수 있다면| 기호를 이용해 or 연산자를 표현할 수 있다.아래 코드는 변수에 숫자 또는 문자를 집어넣을 수 있다.let zipCode :string | number = &#39;11333&#39;타입스크립트에서는 type 키워드를 이용해 타입을 변수처럼 담아서 사용이 가능하다. 이렇게 타입을 지정하는 것을 type alias라고 한다.위에서 | 기호를 사용해서 여러가지 타입의 데이터를 들어오도록 했던 것을 type 키워드로 나타내면 다음과 같다.type 키워드를 사용해 타입을 변수처럼 담을 때에는 보통 대문자로 변수명을 시작한다.type ZipType = string | numberlet zipCode :ZipType = 11133string, number 와 같은 타입뿐만 아니라 나만의 타입을 만들어서 사용하는 것도 가능하다. 만약 동물의 종을 말티즈와 치와와만 받고싶은 타입을 만들고자한다면 아래와 같이 나타낼 수 있다.이런 타입을 literal type 이라고 부른다.type AnimalSpecies = &#39;말티즈&#39; | &#39;치와와&#39;let animal :AnimalSpecies = &#39;말티즈&#39;함수는 파라미터와 return 값이 어떤 타입일지 지정 가능하다.만약 지정되어 있는 타입과 다른 파라미터와 return 값이 있을 경우 에러를 내준다.return 할 값이 없는 경우 void 타입으로 설정 가능하다.function typeFunc(x: number) :number { return x * 2}타입스크립트는 지금 변수의 타입이 확실하지 않으면 마음대로 연산할 수 없다.따라서, narrowing이나 assertion을 사용해 타입을 확실히 해주어야 한다.narrowing은 if문을 통해 타입을 정해주는 것이고,assertion은 as를 이용해 타입을 덮어쓰는 방법이다.// narrowing을 이용한 타입 지정function narrowingType(x) { if (typeof x === &#39;string&#39;) { return x + &#39;1&#39;; } else if (typeof x === &#39;number&#39;) { return x + 1; } else { return 0; }}narrowing에서는 typeof 를 이용해 변수가 어떤 타입인지 체크한다.타입이 array인지 체크할 때에는 Array.isArray() 를 사용할 수 있다.// assertion을 이용한 타입 지정function assertionType(x) { var arr = []; arr[0] = x as number; // &#39;x의 타입을 number로 생각해주세요&#39;}assertion은 아무때나 사용해선 안되고, 무슨 타입이 들어올 지 확실할 때에만 사용해야 한다. 주로 에러를 디버깅 할 때 잠깐 사용한다.array 자료 안에 순서를 포함해 어떤 타입들이 들어올지 정확히 지정하고 싶으면 튜플(Tuple) 타입을 사용할 수 있다. 튜플타입은 다음과 같이 사용한다.type Member = [number, boolean];let john:Member = [100, false]object타입도 정의가 너무 길면 type키워드로 변수에 담아서 사용이 가능하다.type 키워드 대신 비교적 최근에 나온 interface 키워드를 사용해도 무방하다.object에 특정 속성이 옵션이면 ?통해 나타낼 수 있다.type Member = { name? : string, age : number}let choi :member = { name : &#39;kim&#39;, age : 50}object내에 어떤 속성이 들어갈지 아직 모른다면 object 전체에 타입 지정도 가능하다. 이것을 index signature라고 하며 다음과 같이 사용 가능하다.type Member = { [key: string]: number}let choi :member = { weight: 100, age : 50}key 값은 string 타입, value 값은 number 타입만 들어올 수 있다.class도 타입 설정이 가능하다.다만, 중괄호 내에 미리 변수를 만들어놔야 constructor 내에서 this.변수명 과 같이 사용이 가능하다.class Person { name; constructor(name :string){ this.name = name; }} 참고강의 타입스크립트 문법 10분 정리와 설치 셋팅 " }, { "title": "[React] 간단한 Blog App 만들면서 React 기본 다지기 - 2", "url": "/posts/React-Blog-App-2/", "categories": "React", "tags": "Javascript, React, useState, props", "date": "2022-07-24 00:00:00 +0900", "snippet": "1. Blog App 만들기1-1. 중요한 변수를 담을때는 useState()블로그에는 포스팅되는 글들은 제목, 내용과 같이 중요한 데이터를 담고있다. 중요한 데이터들은 React Hook중 하나인 useState()를 사용해 데이터를 저장하는 것이 좋다.그렇다면 중요한 변수의 기준이 뭘까? 값이 변경되자마자 html에 반영되어야 하는 데이터 자주 변경되는 데이터위와 같이 중요한 데이터를 정의 내릴 수 있다.state변수는 값이 변경되면 html을 자동으로 재렌더링 해주기 때문에 위 두 기준에 부합할 경우 useState()를 사용해 변수를 생성해주는 것이 좋다.위에 해당되는 것이 아니면 일반 변수 선언 방법인 let, const를 사용해도 무관하다.useState()의 사용 방법은 다음과 같다.// 1. useState importimport {useState} from &#39;react&#39;// 2. 변수 선언let [변수명, 변수를 변경 할때 호출할 함수명] = useState(value)useState()로 선언한 변수는 변수를 변경할때 함수를 호출해서 변경하게 되는데 그때 변수를 변경할 때 호출 할 함수명(변경할 변수의 값) 변경 함수를 호출해 변수의 값을 변경할 수 있다.만약, state변경 함수로 값을 변경하지 않고 일반 대입식을 사용해 값을 변경할 경우 html 재렌더링이 안되게 되어 변경된 값을 화면에서 확인할 수 없다.// useState() 예시let [name, setName] = useState(&#39;홍시&#39;) // useState로 변수 선언setName(&#39;이홍시&#39;) // 변수 값 변경useState()로 state 변수를 만들 때 사용되는 문법은 구조분해할당(Destructuring) 문법이다.1-2. Array, Object State 변수의 값 변경하기배열이나 객체의 state 값을 변경하는 경우에 대해 알아보자.state 변경 버튼을 클릭했을 경우 title의 0번째 인덱스의 state값을 ‘여자코트 추천’으로 변경하고 싶으면 다음과 같이 코드를 짜면 된다고 생각할 것이다.function App(){ let [title, setTitle] = useState( [&#39;남자코트 추천&#39;, &#39;강남 우동맛집&#39;, &#39;파이썬 독학&#39;] ); return ( &amp;lt;button onClick={ ()=&amp;gt;{setTitle([&#39;여자코트 추천&#39;, &#39;강남 우동맛집&#39;, &#39;파이썬 독학&#39;])} }&amp;gt; state 변경 &amp;lt;/button&amp;gt; )}물론 위와 같이 코드를 작성해도 문제없이 동작한다. 하지만 변경이 불필요한 부분까지 다 입력해주어야 하는 번거로움이 있고 정적으로 데이터가 들어가는 방식이라 확장성에 문제가 있다.만약 setTitle(’여자코트 추천’) 이렇게 넣으면 어떻게 될까?답은 정상적으로 작동하지 않는다이다.state 변경함수는 아예 기존에 있던 값을 갈아 치워주기 때문에 정상적으로 동작하지 않는다.자바스크립트의 배열이나 객체는 원시타입이 아닌 reference 타입이기 때문에 배열이나 객체에 담은 변수는 그 변수가 담긴 공간을 가르키는 화살표만 존재하는데, 변수 값을 변경해줘도 화살표는 변경되지 않기 때문에 정상적으로 작동하지 않는 것이다.따라서 spread operator 문법을 통해 화살표의 방향까지 바꿔주어야 state 변경이 정상적으로 가능하다. spread operator 문법을 통해 state값을 변경하는 방법은 아래와 같다.function App(){ let [title, setTitle] = useState( [&#39;남자코트 추천&#39;, &#39;강남 우동맛집&#39;, &#39;파이썬 독학&#39;] ); return ( &amp;lt;button onClick={ ()=&amp;gt;{ let copy = [...title] // spread operator 문법 사용 copy[0] = &#39;여자코트 추천&#39; setTitle(copy) }}&amp;gt; state 변경 &amp;lt;/button&amp;gt; )}spread operator 문법은 독립적인 배열의 복사본을 생성한다. 이 복사본을 생성하는 것을 shallow copy 또는 deep copy 라고 한다.1-3. 컴포넌트react에서는 컴포넌트라는 독립적인 단위를 통해 UI를 재사용 할 수 있다. 그렇다면 어떤 HTML들을 컴포넌트로 만들어 주는 것이 좋을까? 사이트에 반복해서 나타나는 HTML 덩어리 내용이 자주 변경될 것 같은 HTML 부분들 페이지 단위위 기준에 부합하면 컴포넌트로 만들어주는 것이 UI 재사용에 용이하다.react에서 컴포넌트 만드는 방법은 함수를 만드는 방법과 동일하다. App.js 내에서 모달 컴포넌트를 생성해 메인페이지에 모달 컴포넌트를 넣어보자.function Modal(){ return ( &amp;lt;div&amp;gt;모달입니다.&amp;lt;/div&amp;gt; )}let Modal = () =&amp;gt; { return ( &amp;lt;div&amp;gt;모달입니다.&amp;lt;/div&amp;gt;)}이렇게 모달 컴포넌트를 생성할 수 있다. 두 가지 방법 중 어느 방법을 사용해도 무관하다.react에서 컴포넌트 생성할 때 규칙이 있는데 규칙은 다음과 같다. 컴포넌트 작명시 첫 문자는 영어대문자로 작명한다. return() 내에는 html 태그들이 평행하게 여러개 들어갈 수 없다. 다른 컴포넌트 내부에 또 다른 컴포넌트를 생성할 수 없다.App 내에서 모달 컴포넌트를 사용하고 싶으면 혹은 이렇게 작성해주면 사용할 수 있다.function App ( return ( &amp;lt;Modal/&amp;gt; // 방법1 &amp;lt;Modal&amp;gt;&amp;lt;Modal/&amp;gt; // 방법2 )}같은 파일내에 컴포넌트를 생성했으면 위와 같이 바로 사용가능하지만 만약 컴포넌트 파일을 따로 분리해둔 경우에는 생성한 컴포넌트를 export하고 사용하고 싶은 곳에서 import 해서 사용해야 한다.1-4. 동적 컴포넌트 만들기react에서 동적 컴포넌트 만드는 방법은 다음과 같다. html/css로 UI 디자인 UI 현재 상태를 state에 저장 state값의 변화에 따라서 UI가 어떻게 보일지 조건문으로 작성이 방법을 이용해서 간단한 모달창을 만들어 보자!1. html/css로 UI 디자인function Modal(props) { return ( &amp;lt;div className=&quot;modal_bg&quot;&amp;gt; &amp;lt;div className=&quot;modal&quot;&amp;gt; &amp;lt;h4&amp;gt;Title:&amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt;날짜&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;상세내용&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; )}export default Modal매우 간단하게 모달창 UI를 구현했다.2. UI 현재 상태를 state에 저장한다.let [modal, setModal] = useState(false)모달의 상태를 저장하는 변수를 생성해주었다.모달창은 보통 닫혀있거나 열려있거나의 상태를 가지고 처음에는 닫혀있는 상태로 있기 때문에 false로 초기화해주었다.3. state값의 변화에 따라 UI 변경하기function app() { return ( modal값이 true면 &amp;lt;Modal&amp;gt;&amp;lt;/Modal&amp;gt; modal값이 false면 아무것도 보여주지마세요. )}export default Modal우리가 원하고자 하는 것은 위의 코드 처럼 나타낼 수 있는데 보통 저 경우에는 if문을 사용한다.react에서는 JSX 문법을 사용하고 JSX문법은 if-else 문법을 바로 사용할 수 없다.그 대신 삼항연산자를 사용해 위 코드를 바꿔볼 수 있다.function app() { return ( { modal? &amp;lt;Modal&amp;gt;&amp;lt;/Modal&amp;gt; : null } )}export default Modal1-5. 동일한 div박스들을 반복문으로 줄이기만든 블로그 웹페이지를 보면 포스팅 글들이 모두 동일한 구조를 갖고 있는 것을 볼 수 있다.이런 부분들은 react에서 map 함수를 사용해 코드를 축약할 수 있다.function App (){ return ( &amp;lt;div&amp;gt; { title.map((t, i) =&amp;gt; { return ( &amp;lt;div className=&quot;list&quot;&amp;gt; &amp;lt;h4&amp;gt;{ t[i] }&amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt;2월 18일 발행&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ) }) } &amp;lt;/div&amp;gt; )}1-6. 부모 컴포넌트의 state 가져다 쓰기 - props컴포넌트간 데이터 통신을 할때는 props 를 사용한다.이전에 만들었던 모달창의 background 를 클릭했을 때 모달창이 닫히게끔 기능을 구현하고 싶으면자식 컴포넌트(Modal)에서 부모 컴포넌트(App)의 modal 값을 가져와 모달의 background를 클릭 했을 때 modal값을 false로 변경해주면 된다.function App (){ let [modal, setModal] = useState(false); return ( &amp;lt;div&amp;gt; &amp;lt;Modal modal={modal} setModal={setModal}&amp;gt;&amp;lt;/Modal&amp;gt; &amp;lt;/div&amp;gt; )}function Modal(props) { return ( &amp;lt;div className=&quot;modal_bg&quot; onClick={() =&amp;gt; {props.setModal(false)}}&amp;gt; &amp;lt;div className=&quot;modal&quot;&amp;gt; &amp;lt;h4&amp;gt;Title:&amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt;날짜&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;상세내용&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; )}위 코드에서 3가지 부분만 보면 props 사용법을 알 수 있다. &amp;lt;Modal modal={modal}&amp;gt;&amp;lt;/Modal&amp;gt; ⇒ 자식 컴포넌트를 선언하는 부분 내부에서 자식컴포넌트에서 쓰일 변수명 = { 부모컴포넌트에서 보낼 변수명 } 를 포함해준다. function Modal(props) / function Modal({modal, setModal}) ⇒ 자식 컴포넌트에 파라미터에 props를 추가한다. 변수 사용 시 props를 따로 적고싶지 않으면 오른쪽과 같이 파라미터를 추가해주면 된다. &amp;lt;div className=&quot;modal_bg&quot; onClick={() =&amp;gt; {props.setModal(false)}}&amp;gt; / &amp;lt;div className=&quot;modal_bg&quot; onClick={() =&amp;gt; {setModal(false)}}&amp;gt; ⇒ 부모 컴포넌트에서 받은 변수를 props.변수명으로 사용한다. 2번에서 우측 방법으로 파라미터 전달시에는 props를 따로 적어주지 않아도 된다. 코드를 보면 알 수 있겠지만 자식 컴포넌트에서는 부모 컴포넌트에서 받은 변수를 사용할 수는 있지만 대입식으로 값을 변경 할 수 는 없다. 따라서 값 변경 함수도 props로 전달해주고 그 함수를 통해 변수 값을 변경해주어야 한다.이렇게 코딩애플님의 강의를 들으면서 React의 기초를 다지면서 간단한 블로그 앱을 만들어보았다. 참고강의 [React] React 리액트 기초부터 쇼핑몰 프로젝트까지! " }, { "title": "[React] 간단한 Blog App 만들면서 React 기본 다지기 - 1", "url": "/posts/React-Blog-App-1/", "categories": "React", "tags": "Javascript, React, library", "date": "2022-07-12 00:00:00 +0900", "snippet": "이번 포스팅은 웹 프론트엔드 라이브러리인 React를 사용해 간단한 블로그를 만들어 볼 것이다.회사에서 Vue 프레임워크를 사용하다보니 1년전에 공부했던 React에 대해 거의 다 까먹은 상태이다.왜 갑자기 React를 공부하느냐하면 ,, Vue에 대해서 조금 익숙해 지다보니 1년 전에 공부했을 때 너무 어렵게 느꼈던 React도 Vue가 익숙해진 상태에서 다시 공부하면 더 빠르게 이해할 수 있을 거 같았고, 사이드 프로젝트를 진행하고 싶은데 Vue보다 React 개발자를 구하는 곳이 훨씬 많았다..마침 1년전쯤 수강해놨던 강의 만료 기간이 일주일이 남았길래 일주일 안에 빠르게 React 기본을 다시 공부 할 것이다 !!!!강의에서 간단한 블로그를 만들며 배웠던 부분을 다시 한 번 정리해보자.1. React 시작 하기1-1. React는 왜 사용할까?웹사이트의 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현하는 방식이 SPA(Single Page Application)이다. 이 방식에서는 html 파일은 딱 하나만 존재한다.하나의 페이지에 담아 동적으로 표현하기 때문에 화면 이동이 부드럽게 동작한다.바닐라 JS를 사용해서 SPA를 만들 수 있지만, React를 사용하면 훨씬 더 빠르고 간단하게 SPA를 쉽게 만들 수 있다.React에서는 function, array, object에 html을 보관하고 재사용 할 수 있어 프로젝트 규모가 커질수로 html의 관리가 용이하다.같은 리액트 문법으로 모바일 앱개발도 가능하다. (React Native)즉, React를 사용하는 이유는 다음과 같다. 빠르고 간단하게 SPA 구현 html 관리 용이 같은 리액트 문법으로 앱개발 가능 (html, css문법만 살짝 다름)1-2. 개발 환경 세팅 &amp;amp; React 설치react도 js 라이브러리이기 떄문에 Node.js가 설치되어 있어야 한다.다음과 같은 순서로 React 프로젝트를 생성한다.1. Node.js 설치 (LTS버전 권장)2. 프로젝트 파일 생성3. 프로젝트 파일에서 `npx create-react-app 프로젝트명`1-3. 프로젝트 디렉토리 구조 node_modules: 프로젝트에 필요한 라이브러리 소스가 포함되어 있는 폴더 public: static 파일들이 포함되어 있는 폴더 src: 메인 폴더로 이 곳에 컴포넌트 폴더를 추가해 컴포넌트 파일을 넣으면 된다. package.json: 프로젝트 정보 + 라이브러리 버전 정보src 폴더 내에 있는 App.js 가 메인 페이지이므로 여기에 코드를 짜면 된다.생성된 프로젝트를 웹사이트로 띄우고 싶다면 npm start 명령어를 입력해 실행한다.1-4. 주요 JSX 문법React에서는 Javascript를 확장한 문법인 JSX 를 사용한다.JSX는 보이는 것으로는 html과 굉장히 비슷해서 이해하는데 어려움은 없지만 몇 가지 주요 문법에 대해서는 알아두는 게 좋다. class 태그는 class가 아닌 className을 사용한다. 변수명을 포함하고 싶을 때는 중괄호 {} 를 이용한다. style 태그를 사용할 때는 `style = 으로 넣고 두 단어 이상의 스타일명 일 경우에는 카멜 케이스로 작성한다.ex) fontSize (x)font-size (o)// jsx 문법 예시function App() { return ( &amp;lt;div&amp;gt; &amp;lt;p style=&amp;gt;안녕하세요.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; )}오늘은 React로 간단한 블로그를 만들기 이전에 React로 프로젝트를 생성하고 React에서 주로 사용되는 문법에 대해 알아보았다.다음 포스팅에서 부터는 본격적으로 React로 블로그를 만들면서 배웠던 부분에 대해 기록할 것이다. 참고강의 [React] React 리액트 기초부터 쇼핑몰 프로젝트까지! " }, { "title": "[Javascript] 디바운싱(Debouncing)과 쓰로틀링(Throttling)", "url": "/posts/JS-debouncing-throttling/", "categories": "Javascript", "tags": "Javascript, Debouncing, Throttling", "date": "2022-06-28 00:00:00 +0900", "snippet": "[Javascript] 디바운싱(Debouncing)과 쓰로틀링(Throttling)이번 포스팅에서는 웹에서 연속적으로 발생되는 이벤트를 제어하여 성능을 향상시키는 2가지 방식인 디바운싱(Debouncing)과 쓰로틀링(Throttling)에 대해 알아보자.먼저 디바운싱은 무엇일까?디바운싱(Debouncing)디바운스는 이벤트를 그룹화하여, 연이어 호출되는 함수들 중 마지막 함수만 호출되도록 하는 기술이다.위 그림을 보면 알 수 있듯이 1부터 8까지 8번의 함수 호출을 디바운싱을 사용하면 단 3번으로 줄일 수 있다. 그 과정은 다음과 같다.예를 들어 input창에 입력되는 입력이벤트를 받아 연관검색어가 뜨도록 처리할 때 디바운싱이 주로 사용되는데, 디바운싱을 사용하지 않으면 사용자가 키보드 하나를 누를때마다 입력이벤트가 발생해 오버클럭(Overclock:과도한 이벤트 발생)이 생겨 성능에 문제가 갈 수 있다.하지만 디바운싱을 사용하면 매 키보드 입력시 함수를 호출하는 것이 아닌 delay time을 지정해 이 delay time 이전에 실행된 이벤트들은 무시하고 delay time 이후에 호출된 이벤트만 실행시키기 때문에 이벤트 발생이 훨씬 감소하게 되고 오버클럭을 막아 리소스 사용량을 줄일 수 있고 성능 문제에 긍정적인 도움을 줄 수 있다.디바운싱 과정은 다음과 같이 설명할 수 있다. setTimeout() 함수를 사용해 0.2초 마다 코드가 실행되도록 한다. 0.2초 이전에 이벤트가 발생하면 clearTimeout() 함수를 사용해 setTimeout()에서 실행될 코드를 취소시킨다. 0.2초 이후에 이벤트가 발생하면 setTimeout()에 있는 코드를 실행시킨다.이 과정을 코드로 간단히 나타내면 다음과 같다.let debounce;let searchInput = document.querySelector(&#39;#search_input&#39;)searchInput.addEventListener(&#39;keypress&#39;, (() =&amp;gt; { clearTimeout(debounce) debounce = setTimeout(() =&amp;gt; { console.log(&#39;keypress 이벤트 실행&#39;) }, 500)}))0.5초동안 사용자의 keypress 이벤트가 없으면 콜백 함수를 실행하도록 짜보았다.드바운싱 실행전에는 키보드 누른 그대로 6번의 콜백함수가 실행된다.드바운싱 실행후에는 123456을 입력할동안에는 콜백함수가 실행하지 않다가 모두 입력하고 0.5초 동안 키보드 입력이 없을때 단 한번 콜백함수가 실행되는 것을 볼 수 있다.쓰로틀링(Throttling)쓰로틀링(Throttling)은 정해둔 일정 시간내에 딱 한번만 함수를 호출하도록 하는 기술로 디바운싱과 가장 큰 차이점은 정해진 시간 간격 내에 반드시 최대 한 번 함수가 호출된다는 것이다.쓰로틀링은 사용자가 이벤트를 일으킨 점선 박스 시간동안 기다렸다가, 가장 마지막에 호출된 이벤트를 발생시킨다.쓰로틀링은 스크롤 이벤트를 제어할 때 많이 사용되는데, 바로 이전 포스팅이었던 [Javascript] Intersection Observer API로 무한스크롤 구현하기를 쓰로틀링으로도 구현할 수 있다.쓰로틀링 과정은 다음과 같다. setTimeout()을 이용해 콜백함수를 호출할 일정 시간을 정한다. 일정 시간이 지나면 setTimeout() 콜백함수 내에서 스스로 타이머를 해제시킨 후 다음 코드를 실행시킨다.이 과정을 코드로 간단히 나타내면 다음과 같다.let throttlelet searchInput = document.querySelector(&#39;#search_input&#39;)searchInput.addEventListener(&#39;keypress&#39;, (() =&amp;gt; { if (!throttle) { throttle = setTimeout(() =&amp;gt; { throttle = null console.log(&#39;keypress 이벤트 실행&#39;) }, 1000) }}))1초동안 기다렸다가 마지막에 호출된 이벤트를 발생하도록 코드를 짜보았다.쓰로틀링 실행 전은 위에 드바운스 실행전과 결과가 동일하고 쓰로틀링 실행 후 결과는 다음과 같았다. 참고자료 [Javascript] 디바운싱과 쓰로틀링 [Javascript] Debounce &amp;amp; Throttle " }, { "title": "[Javascript] Intersection Observer API로 무한스크롤 구현하기", "url": "/posts/JS-IntersectionObserverAPI/", "categories": "Javascript", "tags": "Javascript, InterSectionObserver, API", "date": "2022-06-11 00:00:00 +0900", "snippet": "이번 포스팅에서는 프론트엔드를 개발하면 한번쯤은 꼭 구현해보고싶은 무한스크롤을 구현해보려고 한다.무한스크롤을 구현할 수 있는 가장 대표적인 방식은 스크롤 이벤트를 이용하는 것으로 알고 있다. 하지만 이 방식은 스크롤이 발생할때마다 이벤트가 실행되어 웹 성능이 떨어지는 단점이 있어 스로틀링(Throttling)같은 최적화 작업이 늘 동반되어야 했다.그래서 나는 그러한 단점을 보완할 수 있는 방식인 Intersection Observer API를 사용해 무한스크롤을 구현해보려 한다.무한스크롤을 구현해보기전에 많은 양의 정보를 보여주는 UX 방식은 두가지가 있다. 바로 페이지네이션과 무한스크롤이다. 이 둘의 장단점은 무엇일까?무한스크롤 vs 페이지네이션무한스크롤의 장점 사용자 참여 및 콘텐츠 탐색이 쉽다. 클릭보다 더 나은 사용자경험을 제공한다. 모바일에 적합하다.무한스크롤의 단점 페이지 성능이 느려진다. 특정 항목 검색 및 원래 위치로 되돌아오기 힘들다. 페이지의 가장하단인 Footer를 찾기 어렵다.페이지네이션의 장점 사용자의 의도에 맞게 페이지를 넘길 수 있다. 통제감을 느낄 수 있다. 특정 항목의 위치를 파악하기 쉽다.페이지네이션의 단점 추가적인 작업(다음버튼 클릭)을 필요로한다. 한 페이지에 제한된 내용만을 보여줄 수 있다.⇒ 결론적으로, 어느것이 더 좋은 방식이라고 말할 순 없다. 상황에 따라 적절한 인터페이스를 사용하면 된다 !!!Intersection Observer API를 사용해 무한 스크롤을 구현하기자, 이제 본격적으로 Intersection Observer API를 사용해 무한 스크롤을 구현해보려 한다.이 API는 관찰자(observer), 관찰대상(entry), 조건(option), 콜백함수(callback)이 존재한다. 이 API를 사용하는 순서는 다음과 같다. 관찰자(observer)를 생성한다. 관찰할 대상(entry)을 생성한다. 관찰자(observer)는 관찰대상(entry)을 관찰(observe)한다. 관찰대상이 조건(option)을 만족하는 상태에 놓일때 콜백함수(callback)를 실행한다.위 순서를 코드로 구현하면 아래와 같이 나타낼 수 있다. 관찰자(observer)를 생성한다.// 관찰자 생성const observer = new IntersectionObserver(callback, {threshold: 0.7})생성자 함수의 리턴값은 관찰자(observer)가 된다.위 코드에서 조건으로 threshold를 주었는데 저 조건은 관찰대상이 얼마나 화면에 들어왔을 때 콜백함수를 호출할지 결정하는 옵션이다. 기본값은 (0(0%))이고 최대(1(100%))까지 지정할 수 있다.0.7은 화면에 70% 이상 들어왔을 때 콜백함수를 호출한다는 의미이다. 관찰할 대상(entry)을 생성한다.// 관측할 대상을 생성const target = document.querySelector(&#39;#target&#39;)관찰대상은 하나 이상일 수 있다. 관찰자(observer)는 관찰대상(entry)을 관찰(observe)한다.// 관찰 시작observer.observe(target)이제 target이 특정 조건을 만족하게 되는경후 callback 메소드 호출 관찰대상이 조건(option)을 만족하는 상태에 놓일때 콜백함수(callback)를 실행한다.const callback = (entries, observer) =&amp;gt; { entries.forEach((entry) =&amp;gt; { // 교차 관찰자의 루트와 교차하는 경우 -&amp;gt; entry.isIntersecting === true if (entry.isIntersecting) { // 기존 관찰 대상 관찰 중지 observer.unobserve(entry.target) // 로딩 시작 loadingStart() setTimeout(() =&amp;gt; { // 콘텐츠 추가 + 새로운 콘텐츠의 마지막 요소를 관찰 시작 addNewCardItem() loadingFinish() observeLastItem(observer, document.querySelectorAll(&#39;.card&#39;)) }, 2000) } })}이제 관찰 대상이 조건을 만족하게 되는 경우 실행될 callback 메소드까지 구현했다. callback을 제대로 사용하기 위해서는 IntersectionObserver API가 제시하는 방법대로 만들어야한다.무한 스크롤은 다음 콘텐츠를 가져와 보여주기까지 시간이 조금 걸리기 때문에 로딩중임을 표현할 UI가 필요하다. 이걸 표현할 UI로는 처음 사용해보는 Skeleton UI를 선택했다.Skeleton UI는 실제 데이터가 렌더링 되기 전에 보이게 될 화면의 윤곽을 먼저 그려주는 로딩 애니메이션이다. 기존 Spinner에 비해 훨씬 사용자 친화적이고, 사용자 이탈율도 실제로 적다고 한다.다양한 사이트에서 이 애니메이션을 사용하고 있다.유튜브에서 사용중인 Skeleton UI구현하는 방법은 어렵지 않다. 기존에 들어갈 콘텐츠와 똑같은 UI를 만들어 놓고 로딩중일때 이 Skeleton UI를 보여주고 로딩이 끝나면 지우고 들어가야 할 콘텐츠를 붙여주면 된다.소스 코드const makeSkeleton = () =&amp;gt; { const skeleton = document.createElement(&#39;li&#39;) const skeletonImg = document.createElement(&#39;div&#39;) const skeletonText = document.createElement(&#39;p&#39;) skeleton.classList.add(&#39;skeleton&#39;) skeletonImg.classList.add(&#39;skeleton_img&#39;) skeletonText.classList.add(&#39;skeleton_text&#39;) skeletonText.textContent = &#39;&#39; skeleton.appendChild(skeletonImg) skeleton.appendChild(skeletonText) return skeleton}const cards = document.querySelector(&#39;.cards&#39;)const cardItems = document.querySelectorAll(&#39;.card&#39;)const skeletonItems = Array.from({length: cardItems.length}, () =&amp;gt; makeSkeleton())const addSkeleton = () =&amp;gt; { skeletonItems.forEach((item) =&amp;gt; { cards.appendChild(item) })}const removeSkeleton = () =&amp;gt; { skeletonItems.forEach((item) =&amp;gt; { cards.removeChild(item) })}const loadingStart = () =&amp;gt; { addSkeleton()}const loadingFinish = () =&amp;gt; { removeSkeleton()}const addNewCardItem = () =&amp;gt; { cardItems.forEach((item) =&amp;gt; cards.appendChild(item.cloneNode(true)))}const callback = (entries, observer) =&amp;gt; { entries.forEach((entry) =&amp;gt; { // 교차 관찰자의 루트와 교차하는 경우 -&amp;gt; entry.isIntersecting === true if (entry.isIntersecting) { // 관찰 타겟 관찰 중지 observer.unobserve(entry.target) // 로딩 시작 loadingStart() setTimeout(() =&amp;gt; { // 콘텐츠 추가 addNewCardItem() loadingFinish() observeLastItem(observer, document.querySelectorAll(&#39;.card&#39;)) }, 2000) } })}// 마지막 아이템을 관찰하도록 하는 함수const observeLastItem = (observer, items) =&amp;gt; { const lastItem = items[items.length - 1] observer.observe(lastItem)}const observer = new IntersectionObserver(callback, {threshold: 0.7})observeLastItem(observer, cardItems) /*style.css*/body { background: black;}* { margin: 0; padding: 0; box-sizing: border-box;}h1 { margin-top: 20px; color: aliceblue; text-align: center; font-size: 60px;}.cards { display: flex; justify-content: center; flex-wrap: wrap; width: 100%; height: 100%; padding: 20px;}.card,.skeleton { border-radius: 5px; padding: 20px; margin: 10px; background-color: aliceblue; list-style: none;}.card img { width: 350px; height: 300px; object-fit: cover;}.card_text,.skeleton_text { text-align: center; margin-top: 15px; font-size: 18px; font-weight: bold;}.skeleton_img { width: 350px; height: 300px; animation: skeleton-gradient 1.5s infinite ease-in-out;}@keyframes skeleton-gradient { 0% { background-color: rgba(165, 165, 165, 0.1); } 50% { background-color: rgba(165, 165, 165, 0.3); } 100% { background-color: rgba(165, 165, 165, 0.1); }}&amp;lt;!--index.html--&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Hongsi Infinite Photo&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Infinite Hongsi Photo&amp;lt;/h1&amp;gt;&amp;lt;ul class=&quot;cards&quot;&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010303916.png&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시1&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010306045.jpg&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시2&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010306844.jpg&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시3&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010336784.png&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시4&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010413647.jpg&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시5&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010417410.jpg&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시6&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010423158.jpg&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시7&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;card&quot;&amp;gt; &amp;lt;img class=&quot;card_img&quot; src=&quot;image/KakaoTalk_20220611_010425768.jpg&quot; alt=&quot;홍시&quot;&amp;gt; &amp;lt;p class=&quot;card_text&quot;&amp;gt;귀여운 홍시8&amp;lt;/p&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;script src=&quot;app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;완성된 Infinite Hongsi Photo내가 좋아하는 우리집 강아지(홍시) 사진으로 Infinite scroll을 구현해보았다. 참고자료 [UI/UX] Skeleton UI 적용기 IntersectionObserverAPI로 무한스크롤 구현 Intersection Observer API로 무한 스크롤 구현하기 무한스크롤 vs 페이지네이션 " }, { "title": "[FE 지식] 프레임워크(Framework), 라이브러리(Library), 플러그인(Plug-in), 모듈(module) 개념 및 차이점", "url": "/posts/FE-FramworkVSLibraryVSModuleVSPlugin/", "categories": "FE지식", "tags": "FrontEnd, Framwork, Library, Plug-in, Module", "date": "2022-06-08 00:00:00 +0900", "snippet": "프론트엔드를 공부하다보면 꼭 보이는 개념 4가지인 프레임워크, 라이브러리, 플러그인, 모듈의 개념 및 차이점에서 알아보자. 이 4가지들은 비슷한듯 하여 헷갈리기 쉽다. 각각의 개념과 차이점을 통해 정확히 무엇이 다른지 알아보자.프레임워크(Framework)Framework 직역하면 뼈대/구조 이다.Frame은 틀, 규칙/법칙을 의미하고, work는 일,소프트웨어의 목적이라고 할 수 있다.즉, Framework는 목적에 따라 효율적으로 구조를 짜놓은 개발 방식이다.Application 개발 시 필수적인 코드, 알고리즘, 데이터베이스 연동등과 같은 기능들을 위해 어느정도의 뼈대(구조)를 제공해주는 것이다.프레임워크에 종류에는 Spring, ReactJS 등이 있다.라이브러리(Library)Library 직역하면 도서관이라는 뜻이다.마치 여러 책을 모아둔 도서관처럼 특정 기능에 대한 도구/함수들을 모아둔 집합을 라이브러리라고 한다.프레임워크와 라이브러리의 차이점프레임워크는 Flow(흐름)에 대한 제어 권한을 자체적으로 가지고 있다.→ 사용자가 프레임워크의 규칙을 준수해야함으로써라이브러리는 Flow(흐름)에 대한 제어 권한을 사용자가 가지고 있다.→ 사용자가 라이브러리를 가져다가 씀으로써모듈(module)모듈(module)은 재사용 가능한 코드조각이다. 쉽게 말하자면 js나 mjs파일이다. 모듈은 자신만의 파일 스코프(모듈 스코프)를 가지며 export, import 할 수 있다. 보통 클래스 하나 또는 특정한 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성된다.💡 **mjs, js 차이**mjs와 js 파일은 모두 모듈 파일이 될 수 있다. 하지만 아래와 같은 이유에서 mjs를 권장하기도 한다.**1. 명확성을 위해 (어떤 파일이 모듈이고 어떤 파일이 일반 javascript파일인지 명확하게 구분)2. 빌드 도구에 의해 모듈로 구문 분석되도록**그러나 많은 서버에서 js파일은 올바르게 세팅되어있는 반면 mjs파일은 그렇지 않기때문에 일반적으로 .js 파일로 많이 작성한다.일반 스크립트와 구별되는 모듈의 특징은 아래와 같다. 모듈은 항상 defer 속성을 붙인 것처럼 지연 실행된다. (굳이 Body 끝에 적지 않아도 된다.) 모듈은 strict mode로 실행된다. 모듈은 자신만의 스코프를 갖는다. 모듈은 단 한번만 평가(실행)되고 필요한 곳에서 공유된다. 모듈 최상위 레벨 this는 undefined이다. import.meta 객체로 정보를 얻을 수 있다. (ex. import.meta.url) 라이브러리와 모듈의 차이점모듈은 구성 단위, 구성 부분이라는 뜻이다.개발에서 라이브러리와 모듈은 동일한 의미라고 생각하면 된다.두 개념 모두 결론적으로 자주 사용하게 되는 코드를 하나의 함수나 클래스라는 단위로 묶어서 코드를 재사용할 수 있게 하는 것이다.즉, 코드의 집합체이다.플러그인(Plug-in)플러그인은 어떤 특정한 하나의 문제를 해결하기 위한 컴포넌트(component)이다.즉, 사람들이 자주 사용할만한 기능들을 직접 일일이 구현할 필요 없이 필요한 기능들만 그때 그때 찾아서 사용할 수 있도록 미리 만들어 놓은 것이 플러그인이다.라이브러리나 모듈보다 조금 더 작은 개념으로써 플러그인의 집합이 라이브러리라고 보면 된다. 참고자료 프레임워크(Framework), 라이브러리(Library), 플러그인(Plug-in), 모듈(Module)의 차이 웹팩(Webpack) 밑바닥부터 설정하기 자바스크립트 모듈 " }, { "title": "[Vue] Vue 라우터(Router) 설정", "url": "/posts/Vue-router/", "categories": "Vue", "tags": "Vue, router", "date": "2022-06-06 00:00:00 +0900", "snippet": "Vue에서 라우터를 설정하는 방법을 알아보자.먼저 Vue에서 Router와 Routes의 차이는 무엇일까?$RouterRouter는 인스턴스를 나타낸다.Router 인스턴스는 웹 애플리케이션 전체에서 딱 하나만 존재하는 것으로 전반적인 라우터 기능을 관리한다.Router 객체의 property와 method프로퍼티 app : 라우터를 사용하는 루트 Vue 인스턴스 mode : 라우터 모드 (hash모드와 history모드가 있음) options : 라우터의 설정 값(base, mode, routes)를 반환 currentRoute : 현재 라우트에 대한 Route 객체메소드 push(location, onComplete?, onAbort?) : 페이지 이동 실행 메소드, 히스토리에 새 엔트리를 추가하고 브라우저에서 뒤로가기 버튼을 누르면 이전의 URL로 돌아감 replace(location, onComplete?, onAbort?) : 페이지 이동 실행 메소드, 히스토리에 새 엔트리를 추가하지 않음. go(n) : 히스토리 단계에서 n 단계를 이동함, window.history.go(n)와 비슷함. back() : 히스토리에서 한 단계 전으로 돌아감, window.history.back()과 같음. foward() : 히스토리에서 한 단계 앞으로 나아감. addRoute(routes) : 라우터에서 동적으로 라우트를 추가함.$Route현재 활성화된 Route의 상태를 저장한 객체이다.페이지 이동 등으로 라우팅이 발생할 때마다 생성된다.현재의 경로 및 URL 파라미터 등의 정보를 이 객체에서 받을 수 있다.Route 객체의 property와 method프로퍼티 path : 현재 라우트의 경로를 나타내는 문자열 params : 정의된 URL 패턴과 일치하는 파라미터의 키-값 쌍을 담고있는 객체, 파라미터가 없다면 빈 값임. query : 쿼리 문자열의 키-쌍 값을 담고 있는 객체, 쿼리가 없다면 빈 값임. hash : 현재 URL에 URL 해시가 있을 경우 라우트의 해시값을 가짐, 해시가 없다면 빈 값임. fullPath : 쿼리 및 해시를 포함하는 전체 URL name : 이름을 가진 라우트일 경우 라우트의 이름정리하자면, Router를 구성하고 있는 것이 Route이며 Router는 전체 라우팅 기능을 관리하는 인스턴스고 Route는 각 페이지마다의 상태를 저장한 객체인 것이다.그럼 Vue2와 Vue3에서는 라우터를 어떻게 처리하고 관리할까?Vue에서는 Vue-router라는 Vue.js 공식 라이브러리를 사용해 라우터를 처리하고 관리한다.먼저, Vue-router를 설치하자.[npm install/yarn add] vue-router--save그 다음, 라우터를 생성해야하는데 라우터를 생성하는 방식은vue-router 3.x 버전에서 사용하는 인스턴스 방식과 vue-router4 버전 이후에 도입된 create 방식 두 가지가 존재한다. 인스턴스 방식으로 router 생성// 📂routes/router.js 또는 index.jsimport Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;import Home from &#39;../pages/Home&#39;Vue.use(VueRouter)const router = new VueRouter({ mode: &#39;history&#39;, routes: [{ path:&#39;/&#39;, redirect: &#39;/home&#39; }, { path:&#39;/home&#39;, component:Home }]})// 📂main.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import {router} from &#39;../routes/index.js&#39;new Vue({ router, render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;) Create 방식으로 생성// 📂routes/router.js 또는 index.jsimport {createRouter, createWebHashHistory}from &#39;vue-router&#39;import Home from &#39;../pages/Home&#39;export default createRouter({ history: createWebHashHistory(), routes: [ { page: &quot;/home&quot;. name: Home, component: Home } ]})// 📂main.jsimport {createApp} from &#39;vue&#39;import App from &#39;./App.vue&#39;import {router} from &#39;../routes/index.js&#39;createApp(App).use(router).mount(&#39;#app&#39;)라우터 생성을 완료했으면 라우터를 생성한 컴포넌트에 router-view 태그를 선언하면 URL에 맞게 컴포넌트들이 맵핑된다.// 📂App.vue&amp;lt;template&amp;gt; &amp;lt;RouterView/&amp;gt;&amp;lt;/template&amp;gt; 참고자료 Vue 라우터 개념 및 사용방법 Vue.js-route-router-차이 " }, { "title": "[Javascript] 이벤트 위임", "url": "/posts/JS-event-delegation/", "categories": "Javascript", "tags": "Javascript, event-delegation", "date": "2022-04-28 00:00:00 +0900", "snippet": "이번 포스팅은 유데미라는 사이트에서 강의를 진행하시는 Maker Jun 강사님의 Vanilla JS Lv1. 문벅스 카페 메뉴 앱 만들기 스텝1 파트를 수강하고, 배웠던 부분을 까먹지 않기위해 회고하는 포스터를 작성하려고 한다.우선 이 강의를 수강하게 된 이유는 요즘 Vue 프레임워크로 회사에서 업무를 보다보니 Vanila JS에 대한 부족함을 계속 느껴 강의를 수강하고 싶었던 와중 유데미에서 여러 강의들을 할인하고 있었다. 이 강의에 대한 평도 좋았고, 또 강의 커리큘럼을 보니 기초강의지만 리팩토링 하는방법도 강의에 포함되어 있어 들어보기로 했다.강의의 스텝1까지 들어본 결과 강의 난이도는 쉬운편이지만 몰랐던 부분들과 어렴풋이 알고 있던 부분들도 꽤 있었고 더 공부하고 싶은 부분들도 있었다.강의에서 배웠던 부분 중 오늘은 이벤트 위임에 대해서 더 알아보고자 한다.1. 이벤트 위임이벤트 위임은 강의에서 메뉴의 수정과 삭제를 구현하기 위해 사용했었다.이벤트 위임을 알기 위해서는 이벤트 버블링과 캡쳐링에 대한 이해가 필요하다.이벤트 버블링이벤트 버블링이란 특정 엘리먼트에 이벤트가 발생하면 해당 이벤트가 그 엘리먼트의 조상들에게 까지 전달되는 현상이다.&amp;lt;div&amp;gt; 조상 element &amp;lt;p&amp;gt; 자식 element &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;const parent = document.querySelector(&#39;div&#39;)const child = document.querySelector(&#39;p&#39;)function Alert(message) { return function() { alert(message) }}parent.addEventListener(&#39;click&#39;, Alert(&#39;div tag event&#39;))child.addEventListener(&#39;click&#39;, Alert(&#39;p tag event&#39;))위 예시를 보면 div태그와 p태그 클릭시 alert을 띄우도록 코드를 구현했다.parent를 눌렀을 때는 div alert창만 뜨지만, child를 눌렀을 때는 p alert, div alert창 모두 뜨는 것을 확인할 수 있다. 이 현상이 바로 이벤트 버블링이다.이벤트 캡쳐링이벤트 캡쳐링은 특정 엘리먼트에 이벤트가 발생했을 경우 이벤트가 최상단의 부모 엘리먼트로부터 전달되어져 내려오는 현상이다.캡쳐링을 수행하기 위해서는 이벤트 핸들러에 {capture: true} 혹은 true 로 캡쳐링 옵션을 활성화시켜주어야 한다. 디폴트는 false이기 때문에 활성화해주지 않으면 캡쳐링은 일어나지 않는다.const elements = document.querySelectorAll(&#39;*&#39;)for(let el of elements) { el.addEventListener(&#39;click&#39;, e =&amp;gt; alert(`캡쳐링 이벤트 발생: ${el.tagName}`), true)}위 예시를 보면 알 수 있듯이 이벤트 캡처링을 활성화하면 엘리먼트 클릭시 가장 최상단 부모 엘리먼트 부터 클릭된 엘리먼트까지 전달되어 내려오는 것을 알 수 있다. 이 현상이 바로 이벤트 캡쳐링이다.버블링과 캡쳐링 멈추기버블링은 대체로 &amp;lt;html&amp;gt; 엘리먼트까지 올라가는데, 이러한 이벤트를 멈추기 위해서는 최초로 이벤트가 발생되는 엘리먼트의 이벤트 핸들러에 다음과 같은 코드를 작성해주면 된다.event.stopPropagation() // 이벤트 버블링 멈추기위 코드는 캡쳐링을 멈출때에도 동일하게 사용된다.버블링에서는 타겟 엘리먼트만 이벤트가 발생하도록 해주고, 캡처링에서는 타겟 엘리먼트 기준으로 최상단 엘리먼트에만 이벤트가 발생하도록 해준다.만약 하나의 이벤트에 여러 핸들러가 붙어있어 모든 버블링을 멈추고 싶은 경우에는 다음과 같이 코드를 작성해주면 된다.event.stopImmediatePropagation() // 모든 이벤트 버블링 멈추기이벤트 위임이벤트 위임은 캡쳐링과 버블링을 이용한 것으로, 여러 엘리먼트마다 각각 이벤트 핸들러를 할당하지 않고, 공통되는 부모에 이벤트 핸들러를 할당하여 이벤트를 관리하는 방식이다.여러개의 자식 엘리먼트의 이벤트를 관리할때 유용하게 사용된다. 각각의 정해진 액션에 따라 다른 동작을 하는 여러 버튼에 대한 이벤트를 발생시키고자 할 때 모든 버튼에 대해 이벤트 리스너를 등록하는 것은 매우 비효율적이다.따라서 이벤트 위임을 이용해 공통 부모에 이벤트를 등록하고 정해진 데이터의 액션에 따라 다른 함수를 실행하는 것이다.&amp;lt;div id=&quot;crud&quot;&amp;gt; &amp;lt;button id=&quot;create&quot;&amp;gt;생성&amp;lt;/button&amp;gt; &amp;lt;button id=&quot;read&quot;&amp;gt;읽기&amp;lt;/button&amp;gt; &amp;lt;button id=&quot;update&quot;&amp;gt;수정&amp;lt;/button&amp;gt; &amp;lt;button id=&quot;delete&quot;&amp;gt;삭제&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;const crud = document.getElementById(&#39;crud&#39;)crud.addEventListener(&#39;click&#39;, (e) =&amp;gt; { if(e.target.getAttribute(&#39;id&#39;) === &#39;create&#39;) { alert(&#39;생성&#39;) } else if(e.target.getAttribute(&#39;id&#39;) === &#39;read&#39;) { alert(&#39;읽기&#39;) } else if(e.target.getAttribute(&#39;id&#39;) === &#39;update&#39;) { alert(&#39;수정&#39;) } else if(e.target.getAttribute(&#39;id&#39;) === &#39;delete&#39;) { alert(&#39;삭제&#39;) } else { alert(&#39;빈 영역입니다.&#39;) }})위 코드를 통해 이벤트 위임을 간단히 나타낼 수 있다.생성, 읽기, 수정, 삭제 각각의 버튼에 이벤트를 넣지 않고 모든 버튼을 감싸고 있는 부모인 div 박스에 이벤트를 할당해 각각의 버튼 엘리먼트에 이벤트를 주고 있다. 이것이 바로 이벤트 위임이다.그렇다면 왜 이벤트 위임을 사용해야하는 것일까?이벤트 위임을 사용하는 이유모든 엘리먼트에 이벤트 핸들러를 할당하게 되면 엘리먼트가 삭제되는 경우가 있을 때 엘리먼트는 삭제되지만 해당 엘리먼트에 적용되어 있던 이벤트는 삭제되지 않아 메모리 누적이 계속되어 후에는 메모리 누수가 발생할 가능성이 커지게 된다.따라서 메모리 누수의 가능성을 줄이기 위해 이벤트 위임을 사용해주는 것이 좋다. 참고자료 [JavaScript] 이벤트 위임 [JS] 이벤트 전파와 이벤트 위임 왜 이벤트 위임(delegation)을 해야 하는가? " }, { "title": "[HTML/CSS] CSS방법론 - BEM", "url": "/posts/CSS-BEM/", "categories": "HTML/CSS", "tags": "CSS, BEM", "date": "2022-04-28 00:00:00 +0900", "snippet": "[CSS] CSS방법론 - BEMCSS 방법론이란 CSS 클래스 네임을 어떻게 작성할지, 어떤식으로 스타일을 작성할지 등 CSS를 보다 효율적으로 작성하는 아이디어이다.여러 개의 CSS 방법론이 있지만 이러한 방법론들이 공통적으로 중요하게 생각하는 목표가 있다. 코드의 재사용성 용이 직관적인 클래스 네이밍 원활한 유지보수 확장성또한 CSS 선택자로 아이디나 타입 또는 html 태그의 사용을 지향하고 있다.그 이유는 아이디는 클래스와 다르게 재사용이 불가능하며, 마크업을 수정할 경우 태그에 스타일을 적용한 부분을 다시 수정해야할 일이 생길수도 있기 때문이다.오늘은 여러 방법론중에 BEM에 대해 알아보자.1. BEM의 기본 구조BEM은 Block, Element, Modifier를 뜻한다. 이 세가지로 구성되도록 클래스 이름을 짓는 것이 바로 BEM이다..header__navigation--navi-text { color: red;}위 코드가 바로 BEM 규칙을 사용해 클래스 이름을 명명한 것이다.header 가 Block, navigation 는 Element, navi-text 는 Modifier가 된다.BEM은 CSS 방법론의 중요 목표대로 기본적으로 ID를 사용하지 않고 class만을 사용한다.또 ‘어떻게 보이는가’가 아닌 ‘어떤 목적인가’에 따라 이름을 짓는다. 예를 들어, 에러 메시지를 띄우는 빨간색을 가지는 P 태그에는 .red 가 아닌, .error 라는 이름을 지어주어야 한다.또 단어를 연결할때는 navi-text 와 같이 - 하이픈 하나를 사용해서 연결한다.이제 BEM의 기본구조 각각 의미하는 바에 대해 알아보자.1. B(Block)Block은 문단 전체에 적용된 element 또는 element를 담고 있는 컨테이너를 의미한다.1.1 Block 중첩기능Block은 다른 Block내에 중첩될 수 있다. 예를 들어, 헤드 Block은 로고, 검색폼, 메뉴 등 다른 Block등을 포함할 수 있다.1.2 Block 자유로운 배치Block은 페이지 내의 어디든지 이동할 수 있다. 즉, Block만 가져다가 다른 어딘가에 자유롭게 사용이 가능하다.1.3 Block 재사용Block은 헤더에 쓰일 수도 있고, 푸터에 쓰일수도 있고 여기저기에 사용할 수 있다.이렇게 재사용할 수 있는 요소를 Block이라 한다.2. E(Element)Element는 Block을 구성하는 단위이다.Block은 독립적인 형태인 반면, Element는 의존적인 형태이다.자신이 속한 Block 내에서만 의미를 갖기 때문에 Block안에서 다른데로 가져가서 사용할 수 없다.2.1 block과 element의 차이&amp;lt;form class=&quot;search-form&quot;&amp;gt; &amp;lt;input class=&quot;search-form__input&quot;&amp;gt; &amp;lt;button class=&quot;search-form__button&quot;&amp;gt;Search&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;위 코드에서 search-form 은 Block 이고, search-form__input 과 search-form__button 은 Element이다. search-form 은 여기저기 마음껏 사용해도 되지만 내부의 input과 button은 검색을 위 한 것이기 때문에 search-form 안에서만 존재 의미가 있는 element이다.2.2 중첩가능Element도 중첩이 가능하다.&amp;lt;!--잘못된 사용 예시--&amp;gt;&amp;lt;form class=&quot;search-form&quot;&amp;gt; &amp;lt;div class=&quot;search-form__content&quot;&amp;gt; &amp;lt;input class=&quot;search-form__content__input&quot;/&amp;gt; &amp;lt;button class=&quot;search-form__content__button&quot;&amp;gt;Search&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/form&amp;gt;위 코드가 잘못된 예시인 이유는.search-form &amp;gt; .search_form__content &amp;gt; search_form__content_input, search_form__content_button 이 형태로 구조가 짜여져 있다.즉, .block &amp;gt; .block__elemnt1 &amp;gt; .block__element2 이러한 형태라는 것인데 BEM에서는 .block__element1 를 .blcok__element2 의 하위 엘리먼트로 보지 않고 두 엘리먼트 다 .block 의 하위 엘리먼트로만 취급한다는 점이다.따라서 아래와 같이 작성해야 올바른 방법이다.&amp;lt;!--올바른 사용 예시--&amp;gt;&amp;lt;form class=&quot;search-form&quot;&amp;gt; &amp;lt;div class=&quot;search-form__content&quot;&amp;gt; &amp;lt;input class=&quot;search-form__input&quot;/&amp;gt; &amp;lt;button class=&quot;search-form__button&quot;&amp;gt;Search&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/form&amp;gt;block-name__element-name 의 형식을 지켜주어야 한다.3. M(Modifier)Modifier는 블럭이나 엘리먼트의 속성을 담당한다.생긴게 조금 다르거나 다르게 동작하는 block, element를 만들 때 사용한다.&amp;lt;ul class=&quot;tab&quot;&amp;gt; &amp;lt;li class=&quot;tab__item tab__item--focused&quot;&amp;gt;탭 01&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;tab__item&quot;&amp;gt;탭 02&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;tab__item&quot;&amp;gt;탭 03&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;3.1 Boolean 타입위 코드에서 --focused 가 수식어에 해당한다.저렇게 작성된 것을 boolean타입이라고 하며 그 값이 true라고 가정하고 사용한다.3.2 Key-Value 타입또 다른 타입으로는 key-value 타입이 있다.이 타입은 하이픈으로 성질-내용 을 작성한다.&amp;lt;div class=&quot;column&quot;&amp;gt; &amp;lt;strong class=&quot;title title--color-gray&quot;&amp;gt;VIP 로그인 (준비중)&amp;lt;/strong&amp;gt; &amp;lt;form class=&quot;form-login form-login--theme-special form-login--disabled&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; class=&quot;form-login__id&quot;/&amp;gt; &amp;lt;input type=&quot;password&quot; class=&quot;form-login__password&quot;/&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/div&amp;gt;위 예시에서 theme-special 이 key-value 타입에 해당한다.참조 https://blog.naver.com/PostView.naver?blogId=dndlab&amp;amp;logNo=222047505127 https://nykim.work/15 https://blog.illunex.com/bem/" }, { "title": "[Javascript] 함수 호이스팅(hoisting)", "url": "/posts/JS-hoisting/", "categories": "Javascript", "tags": "Javascript, hoisting", "date": "2022-03-06 00:00:00 +0900", "snippet": "호이스팅(Hoisting)은 자바스크립트의 고유 특징 중 하나이다.이번 포스트에서는 변수 선언의 실행 시점과 관련된 특징인 호이스팅에 대해 알아보자.1. 변수 선언의 실행 시점과 변수 호이스팅console.log(score); // undefinedvar score;위 코드를 실행했을때 콘솔에 에러가 나지 않고 undefined가 출력되는 것을 볼 수 있다.변수 선언 코드가 로그 출력 코드보다 뒤에 있음에도 불구하고 왜 에러가 나지 않는 것일까?그 이유는 자바스크립트 엔진은 변수 선언이 소스코드 어디에 있든 다른 코드보다 우선적으로 실행하기 때문이다. 변수 선언(선언 + 초기화)는 런타임 이전 단계에서 먼저 실행되고 로그 출력은 런타임 단계에서 실행되기 때문에 에러가 나지 않는 것이다.즉, 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징이 바로 호이스팅이다. (var, let, const, function, class를 사용해 선언하는 모든 식별자는 호이스팅된다.)2. 값의 할당var score; // 변수 선언score = 80; // 값의 할당그렇다면 값의 할당은 언제 실행될까?값의 할당은 소스코드가 순차적으로 실행되는 런타임 단계에서 실행된다.다음 코드의 결과값을 보면 알 수 있다.console.log(score) // undefinedvar score // 변수 선언 -&amp;gt; 런타임 이전에 실행score = 80 // 값의 할당 -&amp;gt; 런타임때 실행console.log(score) // 80값의 할당은 런타임 단계에서 실행되기 때문에 첫 로그 출력때 80이 아닌 undefined가 출력된 것을 알 수 있다.그럼 선언과 할당을 동시에 했을 경우는 어떻게 될까?console.log(score) // undefinedvar score = 80console.log(score) // 80선언과 할당을 동시에 해도 똑같은 결과가 나온다.그 이유는 자바스크립트 엔진은 선언과 할당을 각각 2개의 문으로 나누어 실행하기 때문이다." }, { "title": "[Javascript] 함수 scope", "url": "/posts/JS-scope/", "categories": "Javascript", "tags": "Javascript, scope", "date": "2022-02-02 00:00:00 +0900", "snippet": "Javascript에서는 스코프(scope)라는 개념이 존재한다.스코프는 범위라는 뜻으로 자바스크립트에서 어떤 의미를 가지는지 알아보자.자바스크립트에서는 보통 변수에 값을 담아 사용하는데, 이때 변수는 지역변수와 전역변수로 나뉘어진다.전역변수와 지역변수자바스크립트에서 함수 안에 포함되지 않은 가장 바깥의 범위에 변수를 전역(global)변수라 하고 함수 내에서 정의한 변수를 지역(local)변수라 한다.let a = &#39;global&#39;;function scopeEx() { let a = &#39;local&#39;; a = &#39;change&#39;;}scopeEx(); alert(a); // &#39;global&#39;위 코드를 보면 함수 바깥에서 전역으로 선언한 전역변수 a가 있고, 함수 내에서 지역으로 선언한 지역변수 a가 있다.함수를 호출하면 a라는 함수에 change라는 값이 들어가야 하는데 결과를 보면 아직 global인 것을 알 수 있다.그 이유는 자바스크립트에 함수 스코프라는 개념 때문이다.스코프(scope)스코프는 범위라는 뜻을 가지고있듯이 함수 내에서 선언된 변수는 그 함수 내에서만 사용 할 수 있다는 것이다.위 코드에서 let a = &#39;local&#39; 이라고 선언된 지역변수 a는 scopeEx() 함수 내에서만 사용할 수 있다.let a = &#39;global&#39;;function scopeEx() { let a = &#39;local&#39;; a = &#39;change&#39;; // 지역변수 a에 값을 바꿈}scopeEx(); alert(a); // 전역변수 a의 값let a = &#39;global&#39;;function scopeEx() { a = &#39;change&#39;;}scopeEx();alert(a); // &#39;change&#39;따라서 함수 scope로 인해 함수 내에서 값을 변경한 a는 지역변수 a이고,함수 밖에서 alert으로 출력한 a는 전역변수 a의 값이 되는 것이다.자바스크립트는 변수의 범위를 호출한 함수의 지역 스코프 부터 전역 변수들이 있는 전역 스코프까지 점차 넓혀가며 찾는데, 첫번째 예시에서는 지역 스코프인 scopeEx() 함수 내에서 지역변수 a를 찾았기 때문에 지역변수 a의 값을 바꾼 것이다.스코프 체인(scope chain)전역변수와 지역변수의 관계에서 스코프 체인(scope chain)이라는 개념이 나오게 된다.위에서 배운 내용을 요약하자면 내부 함수에서는 외부 함수의 변수에 접근 가능하지만 외부 함수에서는 내부 함수의 변수에 접근 할 수 없다는 것이다.let global = &#39;global&#39;;function scopeEx() { console.log(&#39;scopeEx 내부에서 global 출력&#39;, global); // global function scopeChainEx() { let local = &#39;local&#39;; console.log(&#39;scopeChainEx 내부 에서 global 출력&#39;, global); // global } scopeChainEx();}scopeEx();console.log(local); // undefined위 예시를 보면 scopeChainEx() 함수는 global 변수를 찾기 위해 먼저 자기 자신의 스코프인 scopeChainEx() 내에서 찾고, 없으면 한 단계 올라가 scopeEx() 내에서 찾고, 또 없으면 다시 올라가 전역 스코프에서 찾게 된다.결국 전역 스코프에서 global 변수를 찾아 ‘global’ 값을 콘솔에 출력한다.만약 전역 스코프에서도 변수를 찾지 못하면 변수를 찾지 못했다는 에러가 발생한다.이렇게 변수를 찾기 위해 꼬리를 물고 범위를 넓혀나가는 관계를 스코프 체인이라 한다.렉시컬 스코핑(lexical scoping)스코프는 함수를 호출할 때가 아닌 선언할 때 생긴다. 이 개념이 바로 렉시컬 스코핑이다. 💡 스코프는 함수 선언 시 결정된다.렉시컬 스코핑은 다른 말로 정적 스코프(static scope)라고 부르기도 한다.let scope = &#39;scope&#39;;function log() { console.log(scope); // scope}function lexicalScopeEx() { let scope = &#39;lexical scope&#39;; log();}lexicalScopeEx();이제껏 배웠던 스코프의 개념인 지역변수에서 전역변수로 영역을 확장해나가며 변수를 찾는 스코프의 특징을 생각해보면 변수 scope의 값은 lexicalScopeEx() 함수내에서 먼저 찾을 수 있기 때문에 콘솔에는 lexical scope가 찍힐 것이라고 예상할 수 있다.하지만 콘솔에는 scope가 찍히게 된다.이게 바로 앞서 말했듯이 스코프는 호출할 때가 아닌 선언할 때 결정되기 때문이다.함수를 선언하는 순간부터 함수 내부의 변수는 자기 스코프로 부터 가장 가까운 곳에 있는 변수를 계속 참조하게 되는데, 위 예시에서는 log 함수 안의 scope 변수는 선언 시 가장 가까운 전역변수 scope를 참조하게 되어 콘솔에 scope가 찍히게 되는 것 이다.참조 : https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" } ]
